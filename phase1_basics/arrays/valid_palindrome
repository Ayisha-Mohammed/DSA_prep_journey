# Concepts to Remember
# ðŸ”¤ Normalization (Lowercasing and Filtering)
# c.lower() ensures case-insensitive comparison.
# c.isalnum() filters out all non-alphanumeric characters (spaces, punctuation, symbols).

# Example: "A man, a plan" â†’ "amanaplan"
# ðŸ§± String Comprehension
# ''.join(...) combines all filtered characters into one clean string.
# Efficient and readable.

# ðŸ”„ Palindrome Check via Reversal
# s == s[::-1] compares the string to its reverse using Python slicing.
# s[::-1] is a fast way to reverse a string.

# ðŸ’» Time Complexity
# O(n) to filter and lowercase the string.
# O(n) to reverse the string.
# âœ… Total: O(n) time | O(n) space (for the cleaned copy of the string).


class Solution(object):
    def isPalindrome(self, s):
        s = ''.join(c.lower() for c in s if c.isalnum())
        return s == s[::-1]

# âœ… Pros of This Approach:
# Very short and clean.No manual pointer logic.Leverages Python's strengths.
# âŒ Cons:
# Not O(1) space (since it creates a new string).Not ideal in low-level or memory-critical scenarios.
# ðŸ’¡ When to Use This
# Perfect for interview quick passes (clean, readable).# Great for Pythonic one-liners or quick scripts.
# If LeetCode asks for in-place or constant space â†’ use two pointers.

# ðŸ§­ Quick Mental Flow
# Clean string â†’ lowercase + remove junk
# Check if cleaned version is same as reversed






# class Solution:
#     def isPalindrome(self, s: str) -> bool:
#         left, right = 0, len(s) - 1
#         while left < right:
#             while left < right and not s[left].isalnum():
#                 left += 1
#             while left < right and not s[right].isalnum():
#                 right -= 1
#             if s[left].lower() != s[right].lower():
#                 return False
#             left += 1
#             right -= 1
#         return True


# âœ… Key Points to Remember:
# No extra string creation â†’ O(1) space.

# Skips spaces, punctuation using .isalnum().

# Case-insensitive comparison using .lower().

# Time Complexity: O(n)

# Space Complexity: O(1) â†’ better than the slicing method.

# Good for interviews where in-place and optimal solution is expected.
    
# â± Time Complexity: O(n)
# You scan each character at most once (from both ends).

# Skipping non-alphanumeric and comparing takes constant time per step.

# So total operations are proportional to length of string â†’ O(n).

# ðŸ§  Space Complexity: O(1)
# Youâ€™re not creating any new string or data structure.

# Only using a few pointers (left, right) â†’ constant extra space.

# So:
# âœ” Time = O(n) â†’ because every character is checked once
# âœ” Space = O(1) â†’ because no extra memory used based on input size